#!/usr/bin/env python3

"""
Merge and de-dupe overlapping or adjacent IP ranges.

CIDR Merge

Copyright (c) 2018, Kris Feldmann
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above
     copyright notice, this list of conditions and the following
     disclaimer in the documentation and/or other materials provided
     with the distribution.

  3. Neither the name of the copyright holder nor the names of its
     contributors may be used to endorse or promote products derived
     from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"""

import argparse
import copy
import fileinput
import logging
import os
from pathlib import Path
from typing import List, Optional, Tuple

log = logging.getLogger("cidrmerge")


def main():
    """Run the main script logic."""
    args, _ = parse_command_line()

    ranges = convert_lines_to_ranges(read_input(args.files))
    out_ranges = merge_ranges(ranges)

    for cidr in range_to_cidr(out_ranges):
        print(cidr)


def parse_command_line():
    """Parse command line input."""
    help_text = "Merge and de-dupe overlapping or adjacent IP ranges."
    parser = argparse.ArgumentParser(description=help_text)
    parser.add_argument(
        "-v",
        "--verbose",
        action="count",
        default=0,
        help="verbose/debug output",
    )
    parser.add_argument(
        "files",
        metavar="FILE",
        nargs="*",
        help="input file(s) (default: standard input)",
    )
    args = parser.parse_args()

    for file in args.files:
        if not Path(file).exists():
            parser.error(f"Invalid filename: '{file}'")

    if args.verbose >= 1:
        logging.getLogger().setLevel(logging.DEBUG)

    return args, parser


def read_input(filenames: List[str]) -> List[str]:
    """Read CIDRs from files and return them as a list."""
    lines = []
    with fileinput.input(filenames) as input_files:
        for input_line in input_files:
            line = str(input_line).strip()
            if not line:
                continue
            if "#" in line:
                line = line[: line.find("#")].strip()
            lines.append(line)
    return lines


def convert_lines_to_ranges(lines: List[str]):
    """Convert input lines to ranges."""
    ranges = []
    for line in lines:
        try:
            log.debug(f"{line.strip()} -> {__cidr_to_range(line.strip())}")
            ranges.append(__cidr_to_range(line))
        except ValueError as ex:
            log.error(str(ex))
    return ranges


def merge_ranges(input_ranges):
    """Merge input ranges."""
    ranges = []
    iterations = 0
    while True:
        iterations += 1
        log.debug(f"Starting merge iteration {iterations}")
        input_ranges.sort()
        for a in input_ranges:
            for b in input_ranges:
                result = __compare_ranges(a, b)
                if result:
                    log.debug(f"Replacing {repr(a)} with {repr(result)}")
                    a = copy.deepcopy(result)
                else:
                    log.debug(f"No merge; continue with {repr(a)}")
            if a not in ranges:
                log.debug(f"Adding {repr(a)} to the output")
                ranges.append(a)
            else:
                log.debug(f"{repr(a)} is already in the output, skipping")
        if sorted(input_ranges) == sorted(ranges):
            break
        input_ranges = copy.deepcopy(ranges)
        ranges = []
    return ranges


def range_to_cidr(ranges):
    """Convert a list of ranges to list of CIDRs."""
    cidrs = []
    for ip_range in sorted(ranges):
        try:
            for cidr in __range_to_cidrs(ip_range):
                # sys.stdout.write(f"{cidr}\n")
                cidrs.append(cidr)
        except ValueError as ex:
            log.error(str(ex))
            raise SystemExit(1) from ex
    return cidrs


def __ip_to_int(ipaddr) -> int:
    """Convert an ipv4 "dotted-quad" string to an integer."""
    log.debug(f"Starting __ip_to_int() with {ipaddr}")
    a, b, c, d = ipaddr.split(".")
    i = int(a) * (2 ** 24)
    i += int(b) * (2 ** 16)
    i += int(c) * (2 ** 8)
    i += int(d)
    log.debug(f"Returning from __ip_to_int() with {i}")
    return i


def __int_to_ip(i) -> str:
    """Convert an integer to an ipv4 "dotted-quad" string."""
    log.debug(f"Starting __int_to_ip() with {i}")
    a = i // 2 ** 24
    b = (i - a * 2 ** 24) // 2 ** 16
    c = (i - a * 2 ** 24 - b * 2 ** 16) // 2 ** 8
    d = i - a * 2 ** 24 - b * 2 ** 16 - c * 2 ** 8
    log.debug(f"Returning from __int_to_ip() with {a}.{b}.{c}.{d}")
    return f"{a}.{b}.{c}.{d}"


def __cidr_to_range(cidr) -> Tuple[int, int]:
    """Convert CIDR to range.

    Find starting and ending IPs of the provided CIDR and return those two addresses
    as a tuple of integers. Return tuple of 2 ints.
    """
    if "/" in cidr:
        ip, maskbits_s = cidr.split("/", 1)
        mbits = int(maskbits_s)
        if mbits < 1 or mbits > 32:
            raise ValueError(f"[{cidr}] Invalid network mask size: {mbits}")
        start = __ip_to_int(ip)
        end = start + 2 ** (32 - mbits) - 1
        if start % (2 ** (32 - mbits)) != 0:
            x = start - (start % (2 ** (32 - mbits)))
            suggested_start0 = __int_to_ip(x)
            suggested_start1 = __int_to_ip(x + (1 << (32 - mbits)))
            raise ValueError(
                f"[{cidr}] Invalid starting address for /{mbits}. "
                f"Try {suggested_start0} or {suggested_start1}"
            )
    else:
        start = __ip_to_int(cidr)
        end = start
    return (start, end)


def __range_to_cidrs(range_list) -> List[str]:
    """Merge a list of IP ranges.

    From a list of IP ranges (each provided as a tuple of integers),
    produce a list of CIDR strings that together cover all ranges
    without duplication or overlap.
    """
    log.debug(
        f"Starting __range_to_cidrs() with input: {type(range_list)}({repr(range_list)})"
    )
    outlist = []
    a = range_list[0]
    b = range_list[1]
    span = b - a + 1
    log.debug(f"Span = {span}")
    if span == 1:
        log.debug(f"outlist.append: {a} - {b} --> {__int_to_ip(a)}/32")
        outlist.append(f"{__int_to_ip(a)}/32")
        return outlist
    i = 0
    while i < 33:
        x = span >> i
        if x == 1:
            while True:
                if a % (2 ** i) == 0:
                    break
                if i == -1:
                    raise ValueError("Failed to construct a valid CIDR!")
                log.debug(
                    "Invalid mask. Working backwards now to find one that will work."
                )
                i -= 1
            mbits = 32 - i
            log.debug(f"outlist.append: {a} - {b} --> {__int_to_ip(a)}/{mbits}")
            outlist.append(f"{__int_to_ip(a)}/{mbits}")
            consumed = 1 << i
            remainder = span - consumed
            log.debug(f"Remainder = {remainder}")
            if remainder > 0:
                a += consumed
                span = remainder
                log.debug(f"remainder > 0; new starting point a = {a}, span = {span}")
                i = 0
            else:
                break
        elif x == 0:
            raise ValueError(f"Failed to identify suitable mask size for span={span}")
        else:
            i += 1
    return outlist


def __compare_ranges(a, b) -> Optional[Tuple[int, int]]:
    """Compare two ranges.

    If the two can be replaced with one, return that one range (tuple),
    otherwise return None.
    """
    # identical
    if a[0] == b[0] and a[1] == b[1]:
        log.debug(f"__compare_ranges: {repr(a)} and {repr(b)} are identical")
        return None
    # a completely inside b
    if a[0] >= b[0] and a[1] <= b[1]:
        log.debug(f"__compare_ranges: {repr(a)} is inside {repr(b)}")
        return b
    # b completely inside a
    if b[0] >= a[0] and b[1] <= a[1]:
        log.debug(f"__compare_ranges: {repr(b)} is inside {repr(a)}")
        return None
    # aaaa
    #   bbbb  <- a/b overlap or immediately adjacent
    if a[0] < b[0] and a[1] < b[1] and b[0] <= a[1] + 1:
        log.debug(f"__compare_ranges: a/b overlap: a={repr(a)}, b={repr(b)}")
        return (a[0], b[1])
    #   aaaa
    # bbbb    <- b/a overlap or immediately adjacent
    if b[0] < a[0] and b[1] < a[1] and a[0] <= b[1] + 1:
        log.debug(f"__compare_ranges: b/a overlap: a={repr(a)}, b={repr(b)}")
        return (b[0], a[1])
    # no change
    log.debug(f"__compare_ranges: a and b do not overlap: a={repr(a)}, b={repr(b)}")
    return None


if __name__ == "__main__":
    DEFAULT_LEVEL = logging.DEBUG if os.environ.get("DEBUG") else logging.WARNING
    logging.basicConfig(level=DEFAULT_LEVEL)
    main()
